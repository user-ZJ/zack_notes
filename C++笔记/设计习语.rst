设计习语
=============================

1. `RAII`_ (Resource Acquisition Is Initialization)是C++内存和资源管理最重要的机制之一
2. `ScopeGuard`_ 范围守卫
3. `Copy & Swap`_
4. `小对象优化`_
5. `Copy-On-Write`_
6. `空基类优化EBCO`_
7. `Pimpl`_
8. `虚构造器`_
9. `enable_shared_from_this`_
10. `CRTP`_
11. `lambda重载`_
12. `策略设计`_
13. `Type Trait类型萃取`_
14. `SFINAE`_
15. `Minin混入类`_
16. `NVI`_ (Non-Virtual Interface)

RAII
---------------
RAII通过三个环节来保证内存或资源得到确定性释放

1. 构造器中获取内存或资源
2. 析构器中释放内存或资源
3. 栈对象在作用域结束，即确定性调用析构器、回收内存

RAII的析构机制是由编译器根据生命对象生命周期销毁机制自动确保的，无需手工干预，得到确保执行。

RAII机制完善了C++对值语义的坚持

核心优势：

1. 异常免疫，即使出现异常也确保执行析构
2. 同时管理内存与非内存资源(如文件句柄，锁，网络IO等)
3. 不仅管理栈对象，同时管理堆对象
4. 失效即释放，时间确定性(而非主流垃圾收集器的非确定性)
5. RAII针对对象嵌套结构是递归进行的(依赖析构器的递归)
6. RAII和移动语义、智能指针结合之后达成了资源管理正确性和性能的双重保障。
7. RAII和C++对值语义的彻底支持可谓珠联璧合
8. 遵从好的RAII设计规范，是C++实现内存和资源安全的坦途

.. _ScopeGuard:

ScopeGuard
--------------------
ScopeGuard（范围守卫）通过在构造时注入可调用对象，在析构时执行可调用对象，从而利用栈展开机制确保即使异常发生时，
可调用对象也确保得到释放。可以看作是RAII的一种变体形式。

ScopeGuard的可调用对象通常执行一些必须撤销、回退的操作。
可调用对象支持以下任何调用构造：

* 函数指针
* 函数对象
* lambda表达式
* 函数适配器 std::bind,std::mem_fn
* 多态调用对象std::function

案例分析：Folly库中ScopeGuard

.. literalinclude:: code/8_scopeguard.cpp
    :language: cpp

.. _Copy & Swap:

Copy & Swap
---------------------------
Copy & Swap,"拷贝后交换"，可以用在实现赋值操作符时，借用拷贝构造函数来实现，更简洁、易维护、且保证异常安全。

1. 通过调用拷贝构造函数创建一个临时对象temp，该临时对象是参数rhs的一个深拷贝
2. 将该临时对象temp和this对象的各个成员进行交换，包括基本类型成员、对象成员、指针成员。
   交换之后，this对象的成员是rhs的一个深拷贝
3. temp对象在结束时自动析构，指针成员会得到异常安全的释放。


.. _小对象优化:

小对象优化
------------------
小对象优化(SOO)

1. 堆内存分配、释放都有一定的代价，内存不连续，缓存不友好，可能有严重的内存碎片效应，适合存储离散的大量对象
2. 如果有大量细粒度对象，可以考虑使用小对象优化技术将其连续存储在对象池中，或者使用Local Buffer存储在栈上
3. 利用栈作为对象缓冲区即Local Buffer是一种特殊的小对象优化技术，即如果对象size小于某个阈值存储在栈上，大于某个阈值存储在堆上
4. 标准库中的string，function，any等大量使用Local Buffer技术

    - string,24字节(22字符以内)；function,48字节;any,32字节


.. _Copy-On-Write:

Copy-On-Write
-----------------------
Copy-On-Write即更改时拷贝，是对某些较大尺寸、但在系统中又经常出现重复性复制的对象，
使用"共享技术"来进行优化的做法。

* 复制时，采用直接拷贝指针的浅拷贝，并增加引用计数
* 一旦变更时，检查引用计数，如果引用计数大于1，则进行深拷贝，从而避免变更导致之前共享的对象出现状态错误


.. _空基类优化EBCO:

空基类优化EBCO
-----------------------
* 当一个类没有实例成员，且没有虚函数时，称为空类，空类的对象实例在内存上占用一个字节(寻址要求)
* 当一个空类作为其他类的基类时，其在子类中占用的size将为零
* 但作为其他类的成员时(即组合)，至少占用一个字节，加上对齐效应，通常更大
* 因此对于某些类为空类时(例如函数对象)，本来可以使用组合的场景，为了利用这种内存优化，将其设计为基类，此种设计技巧称为空基类优化(Empty Base Class Potimization)
* 空基类优化，时候一种典型的实现继承(而非接口继承)，因此一般设计为私有继承


.. _Pimpl:

Pimpl
--------------------
Pimpl(Pointer to Implementation),将数据成员声明为指针，指向某个具体实现类或抽象类，从而实现稳定的程序库ABI

Pimpl主要作用是隐藏不想暴露的数据接口，减少头文件依赖。

* 编译依赖：消除.h头文件对实现类的依赖(只需要声明，而无需定义的不完整类型)。
  因为指针指向不完整类型是合法的。虽然.cpp实现文件内仍然需要实现类的定义(延迟依赖)。
* 延迟分发：如果使用指针指向抽象类，则由于虚函数的多态分发，将函数调用延迟到运行时，将具有更好的弹性。
* 资源管理：在构造器中初始化实现类，在析构器中释放实现类。

.. _虚构造器:

虚构造器
-----------------
* C++不支持virtual构造器，仅支持virtual析构器
* C++的构造函数中调用虚函数，走的是静态绑定，即调用本类的对应函数，而不是根据对象指针类型来调用对应类的函数
* 如果要想实现虚构造器的效果，多态基类一般需要实现virtual clone，通过对自身进行浅拷贝或者深拷贝
* virtual clone返回值具有一致性，需要返回多态基类的指针，基于内存管理的需求，一般返回智能指针unique_ptr<Base>
* 可以考虑使用CRTP习语来实现多态基类的深拷贝

.. literalinclude:: code/10_virtual_clone.cpp
    :language: cpp


.. _enable_shared_from_this:

enable_shared_from_this
------------------------------------
类的成员函数内不可以直接返回shared_ptr<T>(this),因为会抢夺所有权。

但如需返回，必须实现enable_shared_from_this,本质上是提前将this对象置入shared_ptr,之后使用引用计数管理：

1. **公有继承** 自enable_shared_from_this<T>
2. 调用shared_from_this()方法返回this共享指针
3. 同时注意:不能再创建栈对象或者用new创建堆对象
4. 最佳实践:将构造器设置为私有，使用工厂函数返回shared_ptr<T>对象

.. literalinclude:: code/12_this_share_design.cpp
    :language: cpp


.. _CRTP:

CRTP
---------------
Curiously Recurring Template Pattern(奇异递归模板模式)，简称CRTP，
通过将基类模板参数设置为子类，从而实现静态多态(静态接口)，或者扩展接口(委托实现)

CRTP实现要点：

* class Sub:public Base<Sub> 通过模板参数，将子类类型在编译时注入基类，从而实现在基类中提前获取子类信息
* static_cast<T*>(this)将基类指针转型为模板子类T的指针
* Base类型为不完整类型，不能使用Sub参与内存布局，但可以在函数内使用(发生调用，模板编译时辨析即可)
* 删除对象，也要使用编译时多态进行删除，避免直接delete

.. literalinclude:: code/7_crtp_interface.cpp
    :language: cpp


.. _lambda重载:

lambda重载
------------------
* lambda表达式本质是匿名函数对象，其内重载了operator()调用操作符
* 虽然无法显式获得lambda表达式的类型，但可以使用自动类型推导获得lambda的类型

.. literalinclude:: code/11_lambda_overload.cpp
    :language: cpp


.. _策略设计:

策略设计
----------------
Policy Design 策略设计

* 将一个类或算法的设计分解为各种policy，找到正交分解点。将设计期的各种决定和约束条件留给policy决定
* Policy为泛型函数和类型提供可配置行为，基于行为提供正交设计的灵活性。通常为可调用构造，配置为模板参数

  - 不需要有默认值，通常要显式指定
  - 和其他模板参数通常正交设计关系
  - 通常包含成员函数，也可以是类的静态成员模板
  - 可以聚合在平凡类内，或者模板类内

* Policy使用模板的编译时多态辨析，将选择放在编译时，从而来替换运行时开关选择语句
* 不仅仅限于策略模式，Policy为泛型函数和类型提供可配置行为，基于行为提供正交设计的灵活性。
  通常为可调用构造，配置为模板参数
* 将一个类或算法的设计分解为各种policy,找到正交分解点。将设计期的各种决定和约束条件留给policy决定

.. literalinclude:: code/Policy/policy1.cpp


.. _Type Trait类型萃取:

Type Trait类型萃取
----------------------------
* 通过附加属性，基于类型特征提供正交设计的灵活性
* 聚合了各种相关类型和常量，一般不包含成员函数
* 可以是固定trait(不用模板参数化)，也可是模板，可以构成Traits Template
* Trait参数通常依赖其他模板主参数
* 作为模板参数，通常有默认值
* 注意Traits与Policy的区别：Traits基于类型特征，Policy基于行为


.. _SFINAE:

SFINAE
--------------
SFINAE(substitution failure is not an error) 替换错误不是失败

* 模板编译过程，如果替换参数T产生失败或无意义值，则发生替换错误，忽略失败(不是错误)，不产生该模板参数对应的构造
* 注意：替换过程 和 模板选择实例化 的过程是不同的
* 通过SFINAE，可以根据参数是否满足需求，来决定是否生成某些构造的重载

.. _Minin混入类:

Minin混入类
--------------------
* Minin使用模板参数作为派生类的基类，从而便捷地为类型提供扩展功能(行为)，或者属性(状态)
* 参数变参基类(variable Base class),可以方便地进行多个类型的混入设计
* Minin在组合多个类的功能时，多个类之间的设计是正交关系
* Minin通过模板参数的编译时装配 提供了在Decorator模式运行时装配之外一种灵活的选择

.. literalinclude:: code/10_mixin.cpp
    :language: cpp

.. _NVI:

NVI
---------------
NVI是C++中的一种设计习语，全称为Non-Virtual Interface，即非虚拟接口。
它的主要思想是将类的公共接口设计为非虚拟的，而将实现细节设计为虚拟的。
这样做的好处是可以将类的实现细节隐藏起来，同时也可以保证类的公共接口的稳定性和一致性。

在NVI设计中，类的公共接口通常是由非虚拟函数来实现的，而这些非虚拟函数会调用虚拟函数来完成具体的实现。
这样做的好处是可以保证类的公共接口的稳定性，因为非虚拟函数的签名不会改变，而虚拟函数的实现可以随时修改。

另外，NVI设计还可以提高代码的可维护性和可测试性。
因为类的实现细节被封装在虚拟函数中，所以可以更方便地进行单元测试和模块化开发。

总之，NVI设计是一种非常实用的C++设计习语，可以帮助我们更好地设计和实现类的接口和实现细节。



