树结构
================

树结构通常用来存储逻辑关系为 "一对多" 的数据。例如：

.. image:: /images/tree1.PNG
    :align: center

有关树的术语
---------------

1. **节点**:
   树存储结构中也将存储的各个元素称为 "结点"。还可以进一步分为父节点，子节点，兄弟节点，根节点，叶子节点
2. **子树**:
   通常，我们将一棵树中几个结点构成的“小树”称为这棵树的“子树”。单个结点也可以看作是一棵树，该结点即为根结点。
3. **节点的度**:
   节点拥有子节点的个数。比较一棵树中所有结点的度，最大的度即为整棵树的度。
4. **节点的层次**:
   从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。树中结点层次的最大值，称为这棵树的深度或者高度。
5. **有序树和无序树**:
   如果一棵树中，各个结点左子树和右子树的位置不能交换，那么这棵树就称为有序树。
   反之，如果树中结点的左、右子树可以互换，那么这棵树就是一棵无序树。
6. **森林**:
   由 m（m >= 0）个互不相交的树组成的集合就称为森林。
7. **空树**:
   空树指的是没有任何结点的树，连根结点都没有。
   



二叉树
--------------
满足以下两个条件的树就是二叉树：

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

二叉树具有以下几个性质：

1. 二叉树中，第i层最多有 :math:`2^{i-1}` 个结点。
2. 如果二叉树的深度为 K，那么此二叉树最多有 :math:`2^K-1` 个结点。
3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

满二叉树
````````````````
如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

满二叉树除了满足普通二叉树的性质，还具有以下性质：

1. 满二叉树中第 i 层的节点数为 :math:`2^{i-1}` 个。
2. 深度为 k 的满二叉树必有 :math:`2^k-1` 个节点 ，叶子数为 :math:`2^{k-1}` 。
3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
4. 具有 n 个节点的满二叉树的深度为 :math:`log_2(n+1)` 。

完全二叉树
``````````````````````````
如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质:

1. n 个结点的完全二叉树的深度为 :math:`⌊log_2n⌋+1`。

对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：

1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
2. 如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。
3. 如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。

树的遍历方式
````````````````````
1. 先序遍历
2. 中序遍历
3. 后续遍历
4. 深度优先遍历
5. 广度优先遍历


二叉搜索树
----------------

二叉查找树(ADT)
------------------------
对于树中每个节点X，它的左子树中所有项的值小于X中的项，右子树中的所有项大于X中的项。

删除
`````````````````
1. 如果是叶子节点，直接删除
2. 如果删除的节点有一个儿子，删除后其父节点直接指向其子节点
3. 如果删除的节点有两个儿子，用其右子树的最小数据代替该节点的数据，并递归的删除该节点


平衡二叉树--AVL树
--------------------
自平衡二叉查找树是带有平衡条件的二叉查找树,
由前苏联的数学家Adelse-Velskil和Landis在1962年提出的高度平衡的二叉树，根据科学家的英文名也称为AVL树。
它具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

查找、插入和删除在平均和最坏情况下的时间复杂度都是 :math:`O(logn)` 

**平衡因子**:某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），
平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，
分别对应着左右子树等高，左子树比较高，右子树比较高。

平衡二叉树的再平衡
```````````````````````
把必须再平衡的节点叫做A，由于任意节点最多有两个儿子，因此高度不平衡时，A节点的两棵子树的高度差2。
这种不平衡可能出现以下4种情况：

1. 对A的左儿子的左子树进行一次插入
2. 对A的左儿子的右子树进行一次插入
3. 对A的右儿子的左子树进行一次插入
4. 对A的右儿子的右子树进行一次插入

情形1和4是关于A节点的镜像对称，情形2和3也是关于A节点的镜像对称。因此，理论上只有两种情况，当然从编程的角度来看还是四种情形。

第一种情况插入发生在“外边”的情形（左-左或右-右），该情况通过对树的单旋转而完成调整。
请二种情况插入发生在“内部”的情形（左-右或右-左），该情况通过复杂些的双旋转来处理。

单旋转
```````````````````````
情形1：在子树X中插入，导致子树X多一层，使得节点k2不满足AVL平衡性质

.. image:: /images/平衡树单旋转1.PNG

情形4：插入导致子树Z多一层，使得节点k1不满足AVL平衡性质

.. image:: /images/平衡树单旋转4.PNG

双旋转
`````````````````
情形2：树B或树C中有一颗比树D深2层

.. image:: /images/平衡树双旋转2.PNG

情形3：树B或树C中有一颗比树A深2层

.. image:: /images/平衡树双旋转3.PNG


伸展树(splay tree)
--------------------------
伸展树保证从空树开始任意连续M次对树的操作最多花费O(MlogN)时间。

伸展树的基本想法是，当一个节点被访问后，它就要经过一系列AVL树的旋转被推到根上。


自顶向下伸展树
-------------------------
当项X作为树叶被插入时，称为 **伸展** 的一系列的树旋转使得X称为新的树根。
伸展操作也在查找期间执行，而且如果一项也没找到，那么就对访问路径上的最后一个节点施行一次伸展。


2-3树
------------
一个节点可以有2-3个孩子。这样可以减少平衡二叉树的旋转次数。


B树
--------------------------
B数用来解决数据较多，不能全部装进内存的情形，保证查找时尽可能少的访问磁盘，节约查找数据时间。

阶为M的B树是一棵具有下列结构特性的树：

1. 数据项存储在树叶上
2. 非叶节点存储直到M-1个键，以指示搜索的方向；键i代表子树i+1中最小的键
3. 树的根或者是一片树叶，或者其儿子数在2和M之间
4. 除根外，所有非树叶节点的儿子数在M/2(向上取整)和M之间
5. 所有的树叶都在相同的深度上并有L/2(向上取整)和L之间个数据项

5阶B树，L=5的示例：

.. image:: /images/数据结构/B树1.jpg

.. note:: 

   B树中每个节点代表一个磁盘区块，于是我们根据所存储的项的大小选择M和L。
   假设一个区块容纳8192字节，每个键使用32个字节。在一棵M阶B树中，我们有M-1个键，总数为32M-32字节，再加上M个分支，由于每个分支基本都是另外一些磁盘区块，
   我们假设一个分支是4个字节，这些分支一共4M个字节，一个非页节点总的内存需求为36M-32个字节。使得不超过8192字节的M的最大值为228。因此我们选择 **M=228**。
   假设每个数据记录是256字节，因此我们能够将32个记录装入一个区块中。于是我们选择 **L=32**。
   这样就保证每片树叶有16到32个数据记录，以及每个内部节点(除根外)至少以114中方式分叉。
   假如有1000万个记录，则至多存在625000片树叶。由此得知，在最坏情形下树叶将在第4层上。根据的说，最坏情形的访问次数近似的由 :math:`log_{M/2}N` 给出，
   这个数可以有1的误差(例如，根和下一层节点可以放在主存中，使得经过长时间运行后，磁盘访问将只对第三层或更深层次的需要)

插入
```````````
**将57插入到上图的B树** ：

沿树向下查找，发现57不在树中，此时把它作为第5个儿子添加到树叶中。注意可能要为此重新组织该树叶上的所有数据。
然而与磁盘访问相比(这种情况下它还包含一次磁盘写入)，做这件事的开销可以忽略

.. image:: /images/数据结构/B树2.jpg

**将55插入到上图的B树(树叶已满的情况)** ：

55想要插入的那片树叶已经满了。不过解法并不复杂：由于现在有L+1项，因此把他们分词两片树叶，这两片树叶保证都有所需要记录的最小个数。
我们形成两片树叶，每片3项。写这两片树叶和更新它们的父节点需要3次磁盘访问(父节点中键和分支均发生了变化)。最后得到的B树如下图所示。
虽然分裂节点是耗时的，但它相对来说很少发生。例如，当L=32时，当节点分裂时，分别建立具有16和17项的两片树叶，对于有17项的树叶，
可以再执行15次插入而不用另外分裂。换句话说，对于每次分裂，大致存在L/2次非分裂的插入。

.. image:: /images/数据结构/B树3.jpg

**将40插入到上图的B树(树叶被分裂然后又造成父节点的分裂)**：

前面例子中的节点分裂之所以行得通，是因为其父节点的儿子尚未满员。如果满员了又会怎么样？
将40插入到上图的树中的35-39的叶子节点，导致叶子节点分裂，但是这将使得父节点有6个儿子，可是它只能有5个儿子。
因此要分裂这个父节点。结果如下图所示。当父节点分裂时，必须要更新父节点的键以及父节点的父节点的键，这样就导致额外的两次磁盘写(从而这次插入需要5次磁盘写)。
然而，虽然由于有大量的情况需要考虑而使得程序不那么简单，但这些键以受控的方式在变化。

.. image:: /images/数据结构/B树4.jpg

正如这里的情形所示，当一个非树叶节点分裂时，它的父节点增加一个儿子。如果父节点的儿子个数已经达到了规定的限度怎么办？
在这种情况下，继续沿着树向上分裂节点，直到找到一个父节点它不需要再分裂，或者达到树根。
如果分裂树根，那么就得到两个树根，显然这是不可接收的，但可以建立一个新的根，这个根以分裂得到的两个树根作为它的两个儿子。
**这就是准许树根最少有两个儿子的特权的原因，也是B树增加高度的唯一方式。** 

.. note::

   还有一些其他方法处理儿子过多的情况。一种方法是在相邻节点有空间时，将一个儿子交给该相邻节点领养。
   这种方法要求对父节点进行修改，因为键受到了影响。然而，他趋向于使得节点更满，从而在长时间运行中节省空间。

删除
`````````````````````
可以通过查找要被删除的项并将其删除来执行删除操作。问题在于，如果被删除的项所在的树叶的数据项已经是最小值，那么删除后它的项数就低于最小值了。
我们可以通过在相邻节点本身没有达到最小值时领养一个邻项来矫正这种情况。
如果邻节点的项数也已经是最小值，那么可以和相邻的节点联合形成一片满叶。可是这就意味着其父节点失去一个儿子。
如果失去儿子的结果又引起父节点的儿子数低于最小值，那么使用相同的策略继续进行。
这个过程可以一直上行到根，根不可能只有一个儿子。如果领养过程使得根只有一个儿子，那么删除该根，并让它的儿子作为树的新根。
**这是B数降低高度的唯一方式。**

**从上图的B树中删除99**：由于那片树叶只有两项而它的邻接点也已经是最小值3了，因此把这些项合并成有5项的一片新树叶。
结果，他们的父节点只有两个儿子了，这时该父节点可以从它的邻接点领养，因为邻接点有4个儿子，领养的结果使得双方都有3个儿子。

.. image:: /images/数据结构/B树5.jpg

B+树
--------------
B树和B+树是用于处理大数据量的数据结构。他们都是多路搜索树，允许快速检索和更新数据。

B树是一种平衡树，它允许每个节点包含多个键和值，这些键和值用于索引数据。B树在数据库和文件系统中常用于存储大型索引。

B+树是一种改进的B树，它在B树的基础上进行了优化，以提高查询效率。与B树不同，B+树的所有数据都存储在叶节点，内部节点仅用于索引。这种架构使得B+树更适合用于数据库中的索引，因为它可以连续扫描叶节点，从而实现范围查询。

总的来说，B+树的查询效率更高，但它需要更多的空间存储数据。因此，选择使用B树或B+树取决于实际应用的需求和可用资源。


红黑树
-------------------
参考：https://algorithmtutor.com/Data-Structures/Tree/Red-Black-Trees/

历史上流行的AVL数的另一变种是红黑树。对红黑树的操作在最坏情形下花费O(logN)时间，而且我们将看到，
对于插入操作的一种慎重的非递归实现可以相对容易完成(与AVL树相比)。

红黑树是具有下列着色性质的二叉查找树：

1. 每一个节点或者着红色或者着黑色
2. 根是黑色
3. 如果一个节点是红色，那么它的子节点必须是黑色
4. 从一个节点到一个NULL指针的每条路径都必须包含相同数目的黑色节点

着色规则的一个结论是，红黑树的高度最多是2log(N+1)。因此，查找保证是一种对数操作。

红黑树示例， **双圆圈表示红色节点**

.. image:: /images/数据结构/RedBlackTree1.jpg

红黑树优点：

1. 执行插入的开销相对较低
2. 实践中发生的旋转相对较少

插入
`````````````````
通常把新项作为树叶放到树中。如果把该项涂成黑色，那么肯定违反红黑树的着色性质4，因为将会建立一条更长的黑色路径。
因此，这一项必须是红色。如果它的父节点是黑色，插入完成。
如果它的父节点已经是红色的，那么得到连续的红色节点，这就违反了红黑树的着色性质3。
在这种情况下，必须调整该树以确保满足红黑树的着色性质3(且又不违反着色性质4)。
用于完成这项任务的基本操作是颜色的改变和树的旋转。

如果父节点是红色的，那么有几种情形(每种都有一个镜像对称)需要考虑。

首先假设这个父节点的 **兄弟节点是黑色的** (我们采纳约定:NULL节点都是黑色的)。令X是新加的树叶，P是它的父节点，S是该父节点的兄弟节点(若存在)，
G是祖父节点。在这种情形下只有X和P是红色的，G是黑色的，因为否则就会在插入之前有两个相连的红色节点，违反了红黑树的着色性质。

X和P和G形成一个一字型链或之字形链(两个方向中的任一个方向)。下图指出，当P是一个左儿子时(还有一个对称情形)如果旋转该树。
即便X是一片树叶，我们还是画出了更一般的情形，使得X在树的中间的更一般的旋转

.. image:: /images/数据结构/RedBlackTree2.jpg

第一种情形对应P和G之间的单旋转，第二种情形对应双旋转，改双旋转首先在X和P间进行，然后在X和G之间进行。
在这两种情形下，子树的新根均被涂成黑色，因此，即便曾祖父是红色的，也排除了两个相邻红色节点的可能性。
同样重要的是，这些旋转的结果使通向A、B、C诸路径上的黑色节点个数保持不变。


如果 **兄弟节点S是红色的**，那么会发生什么情况呢？在这种情况下，初始时从子树的根到C的路径上有一个黑色节点。
在旋转后，一定任然还是只有一个黑色节点。但在这两种情形下，在通向C的路径上都有三个节点(新的根，G和S)。
由于只有一个可能是黑色的，又由于不能有连续的红色节点，于是必须把S和子树的新根都涂成红色，而把G涂成黑色。
可是，如果曾祖父也是红色的会怎么样呢？此时可以将这个过程朝着根的方向上滤，就像对B树和二叉堆所做的那样，
直到不再有两个相邻的红色节点或者到达根(它将被重新涂成黑色)处为止。

删除
`````````````
红黑树中删除可以自顶向下进行。每一件工作都归结于能够删除一个叶结点。

如果是红色树叶，直接删除。
如果是黑色树叶，保证自顶向下删除期间树叶是红色的。



参考
-------------
http://data.biancheng.net/tree/

https://zhuanlan.zhihu.com/p/273829162