算法设计
=================

贪心算法
-------------
贪心算法分阶段工作，在每一个阶段，可以认为所做的决定是最好的，而不考虑将来的后果。
一般来说，这意味着选择的是某个局部最优。这种“眼下能够拿到的就拿”的策略即使这种算法名称的来源。

当算法终止时，我们希望局部最优就是全局最优。如果真是这样的话，那么算法就是正确的；否则算法得到一个次优解。

贪心算法的应用：

1. 调度问题
2. 文件压缩

分治算法
-------------
分治算法由两部分组成：

* 分(divide)：递归解决较小的问题（当然除基本情况外）
* 治(conquer)：然后从子问题的解构建原问题

习惯上，在正文中至少含有两个递归调用的例程叫作分治算法，而正文中只含有一个递归调用例程的不是分治算法。
我们一般认为子问题是不相交的。

* 最大子序列和
* :ref:`归并排序`
* :ref:`快速排序`
* :ref:`最近点问题`

动态规划
---------------------
一个可以被数学上递归表示的问题也可以表示成递归算法，在许多情形下对朴素的穷举搜索得到显著的性能改进。

任何数学递推公式都可以直接翻译成递归算法，但是基本现实是编译器常常不能正确地对待递归算法，结果产生低效的程序。

当怀疑可能是这种情况时，必须再给编译器提供一些帮助，将递归算法重新写成非递归算法，让后者把那些子问题的答案系统的记录在一个表中。
利用这种方法的一种技巧称为 **动态规划(dynamic programming)**

* :ref:`斐波那契数列`

